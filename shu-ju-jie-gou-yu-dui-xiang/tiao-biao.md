# 跳表

跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

跳跃表支持平均O\(logN\)、最坏O\(N\)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳表的效率可以和平衡树相媲美，并且跳表实现起来比平衡树更简单，所以不少程序都是用跳表来代替平衡树。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时候，Redis就会使用跳表来作为有序集合键的底层实现。

和链表，字典等数据结构被广泛的应用在Redis内部不同，Redis只在两个地方用到了跳表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外跳表在Redis中没有其他用途。

## 跳表的实现

Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而在skiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等。

![](../.gitbook/assets/image%20%28250%29.png)

* header：指向跳跃表的表头节点
* tail：指向跳跃表的表尾节点
* level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不算在内）
* length：记录跳表的长度，即当前跳表包含的节点树木（表头节点不计算在内）
* level：节点中用L1，L2，L3等字样标记节点的各个层。每个层带了两个属性：前进指针和跨度，前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。
* backward：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点
* 分值：每个节点中的1.0,2.0,3.0是节点所保存的分值。在跳跃表中，节点按照各自所保存的分值从小到达排序。
* 成员对象：每个节点中的o1，o2，o3是节点所保存的成员对象

## 跳跃表节点

![](../.gitbook/assets/image%20%28249%29.png)

### 层

跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快快速访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度越快。

每次创建一个新跳跃表节点的时候，程序都根据幂次定律\(越大的数出现的概率越小\)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。

### 前进指针

每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向，遍历跳跃表中所有节点的路径。

### 跨度

层的跨度span属性用于记录两个节点之间的距离：

* 两个节点之间的跨度越大，他们相距的就越远
* 指向NULL的所有前进指针的跨度都为0，因为他们没有连向任何几点

跨度主要用于计算节点rank的，在查找某个几点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结构就是目标节点在跳跃表中的排位。

### 后退指针

节点的后退指针用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。

### 分值和成员

节点的分值是一个double类型的浮点数，跳跃表中所有节点都按照分值从小到大来排序。节点的成员对象obj属性是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。

在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的。

## 跳跃表

仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个zskiplist结构来持有这些节点，程序可以更方便的对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速的获取跳跃表节点的数量。

```c
typedef struct zskiplist{
    // 表头节点和表尾节点
    struct zkiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
}
```

![](../.gitbook/assets/image%20%28251%29.png)



